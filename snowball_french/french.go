//! Generated from french.sbl by Snowball 3.0.0 - https://snowballstem.org/

package snowball_french

import (
	snowballRuntime "github.com/snowballstem/snowball/go"
)

var A_0 = []*snowballRuntime.Among{
	&snowballRuntime.Among{Str: "col", A: -1, B: -1, F: nil},
	&snowballRuntime.Among{Str: "ni", A: -1, B: 1, F: nil},
	&snowballRuntime.Among{Str: "par", A: -1, B: -1, F: nil},
	&snowballRuntime.Among{Str: "tap", A: -1, B: -1, F: nil},
}

var A_1 = []*snowballRuntime.Among{
	&snowballRuntime.Among{Str: "", A: -1, B: 7, F: nil},
	&snowballRuntime.Among{Str: "H", A: 0, B: 6, F: nil},
	&snowballRuntime.Among{Str: "He", A: 1, B: 4, F: nil},
	&snowballRuntime.Among{Str: "Hi", A: 1, B: 5, F: nil},
	&snowballRuntime.Among{Str: "I", A: 0, B: 1, F: nil},
	&snowballRuntime.Among{Str: "U", A: 0, B: 2, F: nil},
	&snowballRuntime.Among{Str: "Y", A: 0, B: 3, F: nil},
}

var A_2 = []*snowballRuntime.Among{
	&snowballRuntime.Among{Str: "iqU", A: -1, B: 3, F: nil},
	&snowballRuntime.Among{Str: "abl", A: -1, B: 3, F: nil},
	&snowballRuntime.Among{Str: "Ièr", A: -1, B: 4, F: nil},
	&snowballRuntime.Among{Str: "ièr", A: -1, B: 4, F: nil},
	&snowballRuntime.Among{Str: "eus", A: -1, B: 2, F: nil},
	&snowballRuntime.Among{Str: "iv", A: -1, B: 1, F: nil},
}

var A_3 = []*snowballRuntime.Among{
	&snowballRuntime.Among{Str: "ic", A: -1, B: 2, F: nil},
	&snowballRuntime.Among{Str: "abil", A: -1, B: 1, F: nil},
	&snowballRuntime.Among{Str: "iv", A: -1, B: 3, F: nil},
}

var A_4 = []*snowballRuntime.Among{
	&snowballRuntime.Among{Str: "iqUe", A: -1, B: 1, F: nil},
	&snowballRuntime.Among{Str: "atrice", A: -1, B: 2, F: nil},
	&snowballRuntime.Among{Str: "ance", A: -1, B: 1, F: nil},
	&snowballRuntime.Among{Str: "ence", A: -1, B: 5, F: nil},
	&snowballRuntime.Among{Str: "logie", A: -1, B: 3, F: nil},
	&snowballRuntime.Among{Str: "able", A: -1, B: 1, F: nil},
	&snowballRuntime.Among{Str: "isme", A: -1, B: 1, F: nil},
	&snowballRuntime.Among{Str: "euse", A: -1, B: 12, F: nil},
	&snowballRuntime.Among{Str: "iste", A: -1, B: 1, F: nil},
	&snowballRuntime.Among{Str: "ive", A: -1, B: 8, F: nil},
	&snowballRuntime.Among{Str: "if", A: -1, B: 8, F: nil},
	&snowballRuntime.Among{Str: "usion", A: -1, B: 4, F: nil},
	&snowballRuntime.Among{Str: "ation", A: -1, B: 2, F: nil},
	&snowballRuntime.Among{Str: "ution", A: -1, B: 4, F: nil},
	&snowballRuntime.Among{Str: "ateur", A: -1, B: 2, F: nil},
	&snowballRuntime.Among{Str: "iqUes", A: -1, B: 1, F: nil},
	&snowballRuntime.Among{Str: "atrices", A: -1, B: 2, F: nil},
	&snowballRuntime.Among{Str: "ances", A: -1, B: 1, F: nil},
	&snowballRuntime.Among{Str: "ences", A: -1, B: 5, F: nil},
	&snowballRuntime.Among{Str: "logies", A: -1, B: 3, F: nil},
	&snowballRuntime.Among{Str: "ables", A: -1, B: 1, F: nil},
	&snowballRuntime.Among{Str: "ismes", A: -1, B: 1, F: nil},
	&snowballRuntime.Among{Str: "euses", A: -1, B: 12, F: nil},
	&snowballRuntime.Among{Str: "istes", A: -1, B: 1, F: nil},
	&snowballRuntime.Among{Str: "ives", A: -1, B: 8, F: nil},
	&snowballRuntime.Among{Str: "ifs", A: -1, B: 8, F: nil},
	&snowballRuntime.Among{Str: "usions", A: -1, B: 4, F: nil},
	&snowballRuntime.Among{Str: "ations", A: -1, B: 2, F: nil},
	&snowballRuntime.Among{Str: "utions", A: -1, B: 4, F: nil},
	&snowballRuntime.Among{Str: "ateurs", A: -1, B: 2, F: nil},
	&snowballRuntime.Among{Str: "ments", A: -1, B: 16, F: nil},
	&snowballRuntime.Among{Str: "ements", A: 30, B: 6, F: nil},
	&snowballRuntime.Among{Str: "issements", A: 31, B: 13, F: nil},
	&snowballRuntime.Among{Str: "ités", A: -1, B: 7, F: nil},
	&snowballRuntime.Among{Str: "ment", A: -1, B: 16, F: nil},
	&snowballRuntime.Among{Str: "ement", A: 34, B: 6, F: nil},
	&snowballRuntime.Among{Str: "issement", A: 35, B: 13, F: nil},
	&snowballRuntime.Among{Str: "amment", A: 34, B: 14, F: nil},
	&snowballRuntime.Among{Str: "emment", A: 34, B: 15, F: nil},
	&snowballRuntime.Among{Str: "aux", A: -1, B: 10, F: nil},
	&snowballRuntime.Among{Str: "eaux", A: 39, B: 9, F: nil},
	&snowballRuntime.Among{Str: "eux", A: -1, B: 1, F: nil},
	&snowballRuntime.Among{Str: "oux", A: -1, B: 11, F: nil},
	&snowballRuntime.Among{Str: "ité", A: -1, B: 7, F: nil},
}

var A_5 = []*snowballRuntime.Among{
	&snowballRuntime.Among{Str: "ira", A: -1, B: 1, F: nil},
	&snowballRuntime.Among{Str: "ie", A: -1, B: 1, F: nil},
	&snowballRuntime.Among{Str: "isse", A: -1, B: 1, F: nil},
	&snowballRuntime.Among{Str: "issante", A: -1, B: 1, F: nil},
	&snowballRuntime.Among{Str: "i", A: -1, B: 1, F: nil},
	&snowballRuntime.Among{Str: "irai", A: 4, B: 1, F: nil},
	&snowballRuntime.Among{Str: "ir", A: -1, B: 1, F: nil},
	&snowballRuntime.Among{Str: "iras", A: -1, B: 1, F: nil},
	&snowballRuntime.Among{Str: "ies", A: -1, B: 1, F: nil},
	&snowballRuntime.Among{Str: "îmes", A: -1, B: 1, F: nil},
	&snowballRuntime.Among{Str: "isses", A: -1, B: 1, F: nil},
	&snowballRuntime.Among{Str: "issantes", A: -1, B: 1, F: nil},
	&snowballRuntime.Among{Str: "îtes", A: -1, B: 1, F: nil},
	&snowballRuntime.Among{Str: "is", A: -1, B: 1, F: nil},
	&snowballRuntime.Among{Str: "irais", A: 13, B: 1, F: nil},
	&snowballRuntime.Among{Str: "issais", A: 13, B: 1, F: nil},
	&snowballRuntime.Among{Str: "irions", A: -1, B: 1, F: nil},
	&snowballRuntime.Among{Str: "issions", A: -1, B: 1, F: nil},
	&snowballRuntime.Among{Str: "irons", A: -1, B: 1, F: nil},
	&snowballRuntime.Among{Str: "issons", A: -1, B: 1, F: nil},
	&snowballRuntime.Among{Str: "issants", A: -1, B: 1, F: nil},
	&snowballRuntime.Among{Str: "it", A: -1, B: 1, F: nil},
	&snowballRuntime.Among{Str: "irait", A: 21, B: 1, F: nil},
	&snowballRuntime.Among{Str: "issait", A: 21, B: 1, F: nil},
	&snowballRuntime.Among{Str: "issant", A: -1, B: 1, F: nil},
	&snowballRuntime.Among{Str: "iraIent", A: -1, B: 1, F: nil},
	&snowballRuntime.Among{Str: "issaIent", A: -1, B: 1, F: nil},
	&snowballRuntime.Among{Str: "irent", A: -1, B: 1, F: nil},
	&snowballRuntime.Among{Str: "issent", A: -1, B: 1, F: nil},
	&snowballRuntime.Among{Str: "iront", A: -1, B: 1, F: nil},
	&snowballRuntime.Among{Str: "ît", A: -1, B: 1, F: nil},
	&snowballRuntime.Among{Str: "iriez", A: -1, B: 1, F: nil},
	&snowballRuntime.Among{Str: "issiez", A: -1, B: 1, F: nil},
	&snowballRuntime.Among{Str: "irez", A: -1, B: 1, F: nil},
	&snowballRuntime.Among{Str: "issez", A: -1, B: 1, F: nil},
}

var A_6 = []*snowballRuntime.Among{
	&snowballRuntime.Among{Str: "al", A: -1, B: 1, F: nil},
	&snowballRuntime.Among{Str: "épl", A: -1, B: -1, F: nil},
	&snowballRuntime.Among{Str: "auv", A: -1, B: -1, F: nil},
}

var A_7 = []*snowballRuntime.Among{
	&snowballRuntime.Among{Str: "a", A: -1, B: 3, F: nil},
	&snowballRuntime.Among{Str: "era", A: 0, B: 2, F: nil},
	&snowballRuntime.Among{Str: "aise", A: -1, B: 4, F: nil},
	&snowballRuntime.Among{Str: "asse", A: -1, B: 3, F: nil},
	&snowballRuntime.Among{Str: "ante", A: -1, B: 3, F: nil},
	&snowballRuntime.Among{Str: "ée", A: -1, B: 2, F: nil},
	&snowballRuntime.Among{Str: "ai", A: -1, B: 3, F: nil},
	&snowballRuntime.Among{Str: "erai", A: 6, B: 2, F: nil},
	&snowballRuntime.Among{Str: "er", A: -1, B: 2, F: nil},
	&snowballRuntime.Among{Str: "as", A: -1, B: 3, F: nil},
	&snowballRuntime.Among{Str: "eras", A: 9, B: 2, F: nil},
	&snowballRuntime.Among{Str: "âmes", A: -1, B: 3, F: nil},
	&snowballRuntime.Among{Str: "aises", A: -1, B: 4, F: nil},
	&snowballRuntime.Among{Str: "asses", A: -1, B: 3, F: nil},
	&snowballRuntime.Among{Str: "antes", A: -1, B: 3, F: nil},
	&snowballRuntime.Among{Str: "âtes", A: -1, B: 3, F: nil},
	&snowballRuntime.Among{Str: "ées", A: -1, B: 2, F: nil},
	&snowballRuntime.Among{Str: "ais", A: -1, B: 4, F: nil},
	&snowballRuntime.Among{Str: "eais", A: 17, B: 2, F: nil},
	&snowballRuntime.Among{Str: "erais", A: 17, B: 2, F: nil},
	&snowballRuntime.Among{Str: "ions", A: -1, B: 1, F: nil},
	&snowballRuntime.Among{Str: "erions", A: 20, B: 2, F: nil},
	&snowballRuntime.Among{Str: "assions", A: 20, B: 3, F: nil},
	&snowballRuntime.Among{Str: "erons", A: -1, B: 2, F: nil},
	&snowballRuntime.Among{Str: "ants", A: -1, B: 3, F: nil},
	&snowballRuntime.Among{Str: "és", A: -1, B: 2, F: nil},
	&snowballRuntime.Among{Str: "ait", A: -1, B: 3, F: nil},
	&snowballRuntime.Among{Str: "erait", A: 26, B: 2, F: nil},
	&snowballRuntime.Among{Str: "ant", A: -1, B: 3, F: nil},
	&snowballRuntime.Among{Str: "aIent", A: -1, B: 3, F: nil},
	&snowballRuntime.Among{Str: "eraIent", A: 29, B: 2, F: nil},
	&snowballRuntime.Among{Str: "èrent", A: -1, B: 2, F: nil},
	&snowballRuntime.Among{Str: "assent", A: -1, B: 3, F: nil},
	&snowballRuntime.Among{Str: "eront", A: -1, B: 2, F: nil},
	&snowballRuntime.Among{Str: "ât", A: -1, B: 3, F: nil},
	&snowballRuntime.Among{Str: "ez", A: -1, B: 2, F: nil},
	&snowballRuntime.Among{Str: "iez", A: 35, B: 2, F: nil},
	&snowballRuntime.Among{Str: "eriez", A: 36, B: 2, F: nil},
	&snowballRuntime.Among{Str: "assiez", A: 36, B: 3, F: nil},
	&snowballRuntime.Among{Str: "erez", A: 35, B: 2, F: nil},
	&snowballRuntime.Among{Str: "é", A: -1, B: 2, F: nil},
}

var A_8 = []*snowballRuntime.Among{
	&snowballRuntime.Among{Str: "e", A: -1, B: 3, F: nil},
	&snowballRuntime.Among{Str: "Ière", A: 0, B: 2, F: nil},
	&snowballRuntime.Among{Str: "ière", A: 0, B: 2, F: nil},
	&snowballRuntime.Among{Str: "ion", A: -1, B: 1, F: nil},
	&snowballRuntime.Among{Str: "Ier", A: -1, B: 2, F: nil},
	&snowballRuntime.Among{Str: "ier", A: -1, B: 2, F: nil},
}

var A_9 = []*snowballRuntime.Among{
	&snowballRuntime.Among{Str: "ell", A: -1, B: -1, F: nil},
	&snowballRuntime.Among{Str: "eill", A: -1, B: -1, F: nil},
	&snowballRuntime.Among{Str: "enn", A: -1, B: -1, F: nil},
	&snowballRuntime.Among{Str: "onn", A: -1, B: -1, F: nil},
	&snowballRuntime.Among{Str: "ett", A: -1, B: -1, F: nil},
}

var G_v = []byte{17, 65, 16, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128, 130, 103, 8, 5}

var G_oux_ending = []byte{65, 85}

var G_elision_char = []byte{131, 14, 3}

var G_keep_with_s = []byte{1, 65, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128}

type Context struct {
	i_p2 int
	i_p1 int
	i_pV int
}

func r_elisions(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	env.Bra = env.Cursor
lab0:
	for {
		var v_1 = env.Cursor
	lab1:
		for {
			if !env.InGrouping(G_elision_char, 99, 116) {
				break lab1
			}
			break lab0
		}
		env.Cursor = v_1
		if !env.EqS("qu") {
			return false
		}
		break lab0
	}
	if !env.EqS("'") {
		return false
	}
	env.Ket = env.Cursor
lab2:
	for {
		if env.Cursor < env.Limit {
			break lab2
		}
		return false
	}
	env.SliceDel()
	return true
}

func r_prelude(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
replab0:
	for {
		var v_1 = env.Cursor
	lab1:
		for range [2]struct{}{} {
		golab2:
			for {
				var v_2 = env.Cursor
			lab3:
				for {
				lab4:
					for {
						var v_3 = env.Cursor
					lab5:
						for {
							if !env.InGrouping(G_v, 97, 251) {
								break lab5
							}
							env.Bra = env.Cursor
						lab6:
							for {
								var v_4 = env.Cursor
							lab7:
								for {
									if !env.EqS("u") {
										break lab7
									}
									env.Ket = env.Cursor
									if !env.InGrouping(G_v, 97, 251) {
										break lab7
									}
									env.SliceFrom("U")
									break lab6
								}
								env.Cursor = v_4
							lab8:
								for {
									if !env.EqS("i") {
										break lab8
									}
									env.Ket = env.Cursor
									if !env.InGrouping(G_v, 97, 251) {
										break lab8
									}
									env.SliceFrom("I")
									break lab6
								}
								env.Cursor = v_4
								if !env.EqS("y") {
									break lab5
								}
								env.Ket = env.Cursor
								env.SliceFrom("Y")
								break lab6
							}
							break lab4
						}
						env.Cursor = v_3
					lab9:
						for {
							env.Bra = env.Cursor
							if !env.EqS("ë") {
								break lab9
							}
							env.Ket = env.Cursor
							env.SliceFrom("He")
							break lab4
						}
						env.Cursor = v_3
					lab10:
						for {
							env.Bra = env.Cursor
							if !env.EqS("ï") {
								break lab10
							}
							env.Ket = env.Cursor
							env.SliceFrom("Hi")
							break lab4
						}
						env.Cursor = v_3
					lab11:
						for {
							env.Bra = env.Cursor
							if !env.EqS("y") {
								break lab11
							}
							env.Ket = env.Cursor
							if !env.InGrouping(G_v, 97, 251) {
								break lab11
							}
							env.SliceFrom("Y")
							break lab4
						}
						env.Cursor = v_3
						if !env.EqS("q") {
							break lab3
						}
						env.Bra = env.Cursor
						if !env.EqS("u") {
							break lab3
						}
						env.Ket = env.Cursor
						env.SliceFrom("U")
						break lab4
					}
					env.Cursor = v_2
					break golab2
				}
				env.Cursor = v_2
				if env.Cursor >= env.Limit {
					break lab1
				}
				env.NextChar()
			}
			continue replab0
		}
		env.Cursor = v_1
		break replab0
	}
	return true
}

func r_mark_regions(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	var among_var int32
	context.i_pV = env.Limit
	context.i_p1 = env.Limit
	context.i_p2 = env.Limit
	var v_1 = env.Cursor
lab0:
	for {
	lab1:
		for {
			var v_2 = env.Cursor
		lab2:
			for {
				if !env.InGrouping(G_v, 97, 251) {
					break lab2
				}
				if !env.InGrouping(G_v, 97, 251) {
					break lab2
				}
				if env.Cursor >= env.Limit {
					break lab2
				}
				env.NextChar()
				break lab1
			}
			env.Cursor = v_2
		lab3:
			for {
				among_var = env.FindAmong(A_0, context)
				if among_var == 0 {
					break lab3
				}
				switch among_var {
				case 1:
					if !env.InGrouping(G_v, 97, 251) {
						break lab3
					}
				}
				break lab1
			}
			env.Cursor = v_2
			if env.Cursor >= env.Limit {
				break lab0
			}
			env.NextChar()
			if !env.GoOutGrouping(G_v, 97, 251) {
				break lab0
			}
			env.NextChar()
			break lab1
		}
		context.i_pV = env.Cursor
		break lab0
	}
	env.Cursor = v_1
	var v_3 = env.Cursor
lab4:
	for {
		if !env.GoOutGrouping(G_v, 97, 251) {
			break lab4
		}
		env.NextChar()
		if !env.GoInGrouping(G_v, 97, 251) {
			break lab4
		}
		env.NextChar()
		context.i_p1 = env.Cursor
		if !env.GoOutGrouping(G_v, 97, 251) {
			break lab4
		}
		env.NextChar()
		if !env.GoInGrouping(G_v, 97, 251) {
			break lab4
		}
		env.NextChar()
		context.i_p2 = env.Cursor
		break lab4
	}
	env.Cursor = v_3
	return true
}

func r_postlude(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	var among_var int32
replab0:
	for {
		var v_1 = env.Cursor
	lab1:
		for range [2]struct{}{} {
			env.Bra = env.Cursor
			among_var = env.FindAmong(A_1, context)
			env.Ket = env.Cursor
			switch among_var {
			case 1:
				env.SliceFrom("i")
			case 2:
				env.SliceFrom("u")
			case 3:
				env.SliceFrom("y")
			case 4:
				env.SliceFrom("ë")
			case 5:
				env.SliceFrom("ï")
			case 6:
				env.SliceDel()
			case 7:
				if env.Cursor >= env.Limit {
					break lab1
				}
				env.NextChar()
			}
			continue replab0
		}
		env.Cursor = v_1
		break replab0
	}
	return true
}

func r_RV(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	return context.i_pV <= env.Cursor
}

func r_R1(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	return context.i_p1 <= env.Cursor
}

func r_R2(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	return context.i_p2 <= env.Cursor
}

func r_standard_suffix(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	var among_var int32
	env.Ket = env.Cursor
	among_var = env.FindAmongB(A_4, context)
	if among_var == 0 {
		return false
	}
	env.Bra = env.Cursor
	switch among_var {
	case 1:
		if !r_R2(env, context) {
			return false
		}
		env.SliceDel()
	case 2:
		if !r_R2(env, context) {
			return false
		}
		env.SliceDel()
		var v_1 = env.Limit - env.Cursor
	lab0:
		for {
			env.Ket = env.Cursor
			if !env.EqSB("ic") {
				env.Cursor = env.Limit - v_1
				break lab0
			}
			env.Bra = env.Cursor
		lab1:
			for {
				var v_2 = env.Limit - env.Cursor
			lab2:
				for {
					if !r_R2(env, context) {
						break lab2
					}
					env.SliceDel()
					break lab1
				}
				env.Cursor = env.Limit - v_2
				env.SliceFrom("iqU")
				break lab1
			}
			break lab0
		}
	case 3:
		if !r_R2(env, context) {
			return false
		}
		env.SliceFrom("log")
	case 4:
		if !r_R2(env, context) {
			return false
		}
		env.SliceFrom("u")
	case 5:
		if !r_R2(env, context) {
			return false
		}
		env.SliceFrom("ent")
	case 6:
		if !r_RV(env, context) {
			return false
		}
		env.SliceDel()
		var v_3 = env.Limit - env.Cursor
	lab3:
		for {
			env.Ket = env.Cursor
			among_var = env.FindAmongB(A_2, context)
			if among_var == 0 {
				env.Cursor = env.Limit - v_3
				break lab3
			}
			env.Bra = env.Cursor
			switch among_var {
			case 1:
				if !r_R2(env, context) {
					env.Cursor = env.Limit - v_3
					break lab3
				}
				env.SliceDel()
				env.Ket = env.Cursor
				if !env.EqSB("at") {
					env.Cursor = env.Limit - v_3
					break lab3
				}
				env.Bra = env.Cursor
				if !r_R2(env, context) {
					env.Cursor = env.Limit - v_3
					break lab3
				}
				env.SliceDel()
			case 2:
			lab4:
				for {
					var v_4 = env.Limit - env.Cursor
				lab5:
					for {
						if !r_R2(env, context) {
							break lab5
						}
						env.SliceDel()
						break lab4
					}
					env.Cursor = env.Limit - v_4
					if !r_R1(env, context) {
						env.Cursor = env.Limit - v_3
						break lab3
					}
					env.SliceFrom("eux")
					break lab4
				}
			case 3:
				if !r_R2(env, context) {
					env.Cursor = env.Limit - v_3
					break lab3
				}
				env.SliceDel()
			case 4:
				if !r_RV(env, context) {
					env.Cursor = env.Limit - v_3
					break lab3
				}
				env.SliceFrom("i")
			}
			break lab3
		}
	case 7:
		if !r_R2(env, context) {
			return false
		}
		env.SliceDel()
		var v_5 = env.Limit - env.Cursor
	lab6:
		for {
			env.Ket = env.Cursor
			among_var = env.FindAmongB(A_3, context)
			if among_var == 0 {
				env.Cursor = env.Limit - v_5
				break lab6
			}
			env.Bra = env.Cursor
			switch among_var {
			case 1:
			lab7:
				for {
					var v_6 = env.Limit - env.Cursor
				lab8:
					for {
						if !r_R2(env, context) {
							break lab8
						}
						env.SliceDel()
						break lab7
					}
					env.Cursor = env.Limit - v_6
					env.SliceFrom("abl")
					break lab7
				}
			case 2:
			lab9:
				for {
					var v_7 = env.Limit - env.Cursor
				lab10:
					for {
						if !r_R2(env, context) {
							break lab10
						}
						env.SliceDel()
						break lab9
					}
					env.Cursor = env.Limit - v_7
					env.SliceFrom("iqU")
					break lab9
				}
			case 3:
				if !r_R2(env, context) {
					env.Cursor = env.Limit - v_5
					break lab6
				}
				env.SliceDel()
			}
			break lab6
		}
	case 8:
		if !r_R2(env, context) {
			return false
		}
		env.SliceDel()
		var v_8 = env.Limit - env.Cursor
	lab11:
		for {
			env.Ket = env.Cursor
			if !env.EqSB("at") {
				env.Cursor = env.Limit - v_8
				break lab11
			}
			env.Bra = env.Cursor
			if !r_R2(env, context) {
				env.Cursor = env.Limit - v_8
				break lab11
			}
			env.SliceDel()
			env.Ket = env.Cursor
			if !env.EqSB("ic") {
				env.Cursor = env.Limit - v_8
				break lab11
			}
			env.Bra = env.Cursor
		lab12:
			for {
				var v_9 = env.Limit - env.Cursor
			lab13:
				for {
					if !r_R2(env, context) {
						break lab13
					}
					env.SliceDel()
					break lab12
				}
				env.Cursor = env.Limit - v_9
				env.SliceFrom("iqU")
				break lab12
			}
			break lab11
		}
	case 9:
		env.SliceFrom("eau")
	case 10:
		if !r_R1(env, context) {
			return false
		}
		env.SliceFrom("al")
	case 11:
		if !env.InGroupingB(G_oux_ending, 98, 112) {
			return false
		}
		env.SliceFrom("ou")
	case 12:
	lab14:
		for {
			var v_10 = env.Limit - env.Cursor
		lab15:
			for {
				if !r_R2(env, context) {
					break lab15
				}
				env.SliceDel()
				break lab14
			}
			env.Cursor = env.Limit - v_10
			if !r_R1(env, context) {
				return false
			}
			env.SliceFrom("eux")
			break lab14
		}
	case 13:
		if !r_R1(env, context) {
			return false
		}
		if !env.OutGroupingB(G_v, 97, 251) {
			return false
		}
		env.SliceDel()
	case 14:
		if !r_RV(env, context) {
			return false
		}
		env.SliceFrom("ant")
		return false
	case 15:
		if !r_RV(env, context) {
			return false
		}
		env.SliceFrom("ent")
		return false
	case 16:
		var v_11 = env.Limit - env.Cursor
		if !env.InGroupingB(G_v, 97, 251) {
			return false
		}
		if !r_RV(env, context) {
			return false
		}
		env.Cursor = env.Limit - v_11
		env.SliceDel()
		return false
	}
	return true
}

func r_i_verb_suffix(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	if env.Cursor < context.i_pV {
		return false
	}
	var v_1 = env.LimitBackward
	env.LimitBackward = context.i_pV
	env.Ket = env.Cursor
	if env.FindAmongB(A_5, context) == 0 {
		env.LimitBackward = v_1
		return false
	}
	env.Bra = env.Cursor
	var v_2 = env.Limit - env.Cursor
lab0:
	for {
		if !env.EqSB("H") {
			break lab0
		}
		env.LimitBackward = v_1
		return false
	}
	env.Cursor = env.Limit - v_2
	if !env.OutGroupingB(G_v, 97, 251) {
		env.LimitBackward = v_1
		return false
	}
	env.SliceDel()
	env.LimitBackward = v_1
	return true
}

func r_verb_suffix(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	var among_var int32
	if env.Cursor < context.i_pV {
		return false
	}
	var v_1 = env.LimitBackward
	env.LimitBackward = context.i_pV
	env.Ket = env.Cursor
	among_var = env.FindAmongB(A_7, context)
	if among_var == 0 {
		env.LimitBackward = v_1
		return false
	}
	env.Bra = env.Cursor
	env.LimitBackward = v_1
	switch among_var {
	case 1:
		if !r_R2(env, context) {
			return false
		}
		env.SliceDel()
	case 2:
		env.SliceDel()
	case 3:
		var v_2 = env.Limit - env.Cursor
	lab0:
		for {
			if !env.EqSB("e") {
				env.Cursor = env.Limit - v_2
				break lab0
			}
			if !r_RV(env, context) {
				env.Cursor = env.Limit - v_2
				break lab0
			}
			env.Bra = env.Cursor
			break lab0
		}
		env.SliceDel()
	case 4:
		var v_3 = env.Limit - env.Cursor
	lab1:
		for {
			among_var = env.FindAmongB(A_6, context)
			if among_var == 0 {
				break lab1
			}
			switch among_var {
			case 1:
				if env.Cursor <= env.LimitBackward {
					break lab1
				}
				env.PrevChar()
				if env.Cursor > env.LimitBackward {
					break lab1
				}
			}
			return false
		}
		env.Cursor = env.Limit - v_3
		env.SliceDel()
	}
	return true
}

func r_residual_suffix(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	var among_var int32
	var v_1 = env.Limit - env.Cursor
lab0:
	for {
		env.Ket = env.Cursor
		if !env.EqSB("s") {
			env.Cursor = env.Limit - v_1
			break lab0
		}
		env.Bra = env.Cursor
		var v_2 = env.Limit - env.Cursor
	lab1:
		for {
			var v_3 = env.Limit - env.Cursor
		lab2:
			for {
				if !env.EqSB("Hi") {
					break lab2
				}
				break lab1
			}
			env.Cursor = env.Limit - v_3
			if !env.OutGroupingB(G_keep_with_s, 97, 232) {
				env.Cursor = env.Limit - v_1
				break lab0
			}
			break lab1
		}
		env.Cursor = env.Limit - v_2
		env.SliceDel()
		break lab0
	}
	if env.Cursor < context.i_pV {
		return false
	}
	var v_4 = env.LimitBackward
	env.LimitBackward = context.i_pV
	env.Ket = env.Cursor
	among_var = env.FindAmongB(A_8, context)
	if among_var == 0 {
		env.LimitBackward = v_4
		return false
	}
	env.Bra = env.Cursor
	switch among_var {
	case 1:
		if !r_R2(env, context) {
			env.LimitBackward = v_4
			return false
		}
	lab3:
		for {
			var v_5 = env.Limit - env.Cursor
		lab4:
			for {
				if !env.EqSB("s") {
					break lab4
				}
				break lab3
			}
			env.Cursor = env.Limit - v_5
			if !env.EqSB("t") {
				env.LimitBackward = v_4
				return false
			}
			break lab3
		}
		env.SliceDel()
	case 2:
		env.SliceFrom("i")
	case 3:
		env.SliceDel()
	}
	env.LimitBackward = v_4
	return true
}

func r_un_double(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	var v_1 = env.Limit - env.Cursor
	if env.FindAmongB(A_9, context) == 0 {
		return false
	}
	env.Cursor = env.Limit - v_1
	env.Ket = env.Cursor
	if env.Cursor <= env.LimitBackward {
		return false
	}
	env.PrevChar()
	env.Bra = env.Cursor
	env.SliceDel()
	return true
}

func r_un_accent(env *snowballRuntime.Env, ctx interface{}) bool {
	context := ctx.(*Context)
	_ = context
	var v_1 = 1
replab0:
	for {
	lab1:
		for range [2]struct{}{} {
			if !env.OutGroupingB(G_v, 97, 251) {
				break lab1
			}
			v_1--
			continue replab0
		}
		break replab0
	}
	if v_1 > 0 {
		return false
	}
	env.Ket = env.Cursor
lab2:
	for {
		var v_2 = env.Limit - env.Cursor
	lab3:
		for {
			if !env.EqSB("é") {
				break lab3
			}
			break lab2
		}
		env.Cursor = env.Limit - v_2
		if !env.EqSB("è") {
			return false
		}
		break lab2
	}
	env.Bra = env.Cursor
	env.SliceFrom("e")
	return true
}

func Stem(env *snowballRuntime.Env) bool {
	var context = &Context{
		i_p2: 0,
		i_p1: 0,
		i_pV: 0,
	}
	_ = context
	var v_1 = env.Cursor
	r_elisions(env, context)
	env.Cursor = v_1
	var v_2 = env.Cursor
	r_prelude(env, context)
	env.Cursor = v_2
	r_mark_regions(env, context)
	env.LimitBackward = env.Cursor
	env.Cursor = env.Limit
	var v_3 = env.Limit - env.Cursor
lab0:
	for {
	lab1:
		for {
			var v_4 = env.Limit - env.Cursor
		lab2:
			for {
				var v_5 = env.Limit - env.Cursor
			lab3:
				for {
					var v_6 = env.Limit - env.Cursor
				lab4:
					for {
						if !r_standard_suffix(env, context) {
							break lab4
						}
						break lab3
					}
					env.Cursor = env.Limit - v_6
				lab5:
					for {
						if !r_i_verb_suffix(env, context) {
							break lab5
						}
						break lab3
					}
					env.Cursor = env.Limit - v_6
					if !r_verb_suffix(env, context) {
						break lab2
					}
					break lab3
				}
				env.Cursor = env.Limit - v_5
				var v_7 = env.Limit - env.Cursor
			lab6:
				for {
					env.Ket = env.Cursor
				lab7:
					for {
						var v_8 = env.Limit - env.Cursor
					lab8:
						for {
							if !env.EqSB("Y") {
								break lab8
							}
							env.Bra = env.Cursor
							env.SliceFrom("i")
							break lab7
						}
						env.Cursor = env.Limit - v_8
						if !env.EqSB("ç") {
							env.Cursor = env.Limit - v_7
							break lab6
						}
						env.Bra = env.Cursor
						env.SliceFrom("c")
						break lab7
					}
					break lab6
				}
				break lab1
			}
			env.Cursor = env.Limit - v_4
			if !r_residual_suffix(env, context) {
				break lab0
			}
			break lab1
		}
		break lab0
	}
	env.Cursor = env.Limit - v_3
	var v_9 = env.Limit - env.Cursor
	r_un_double(env, context)
	env.Cursor = env.Limit - v_9
	var v_10 = env.Limit - env.Cursor
	r_un_accent(env, context)
	env.Cursor = env.Limit - v_10
	env.Cursor = env.LimitBackward
	var v_11 = env.Cursor
	r_postlude(env, context)
	env.Cursor = v_11
	return true
}
